# HG changeset patch
# Date 1300482971 25200
# User marky
# Parent cf5e2b71540bf883e67c8473e8517849e3b0ef3c
pyxpcom: allow callables for interfaces marked as [function]

diff --git a/xpcom/server/policy.py b/xpcom/server/policy.py
--- a/xpcom/server/policy.py
+++ b/xpcom/server/policy.py
@@ -60,20 +60,38 @@ VARIANT_UNICODE_TYPES = xpcom_consts.VTY
                         xpcom_consts.VTYPE_ASTRING 
 
 _supports_primitives_map_ = {} # Filled on first use.
+_function_interfaces_ = [] # Filled on first use
 
 _interface_sequence_types_ = types.TupleType, types.ListType
 _string_types_ = types.StringType, types.UnicodeType
 XPTI_GetInterfaceInfoManager = _xpcom.XPTI_GetInterfaceInfoManager
 
 def _GetNominatedInterfaces(obj):
+    iim = XPTI_GetInterfaceInfoManager()
+
+    real_ret = set()
     ret = getattr(obj, "_com_interfaces_", None)
-    if ret is None: return None
+    if ret is None:
+        if type(obj) == types.FunctionType:
+            # we got a function, try [function]s
+            global _function_interfaces_
+            if not _function_interfaces_:
+                enum = iim.enumerateInterfaces()
+                while not enum.IsDone():
+                    interface_info = enum.CurrentItem(xpcom._xpcom.IID_nsIInterfaceInfo)
+                    enum.Next()
+                    if interface_info.isFunction():
+                        real_ret.add(interface_info.GetIID())
+                        assert interface_info.GetParent().GetIID() == IID_nsISupports
+                _function_interfaces_ = list(real_ret)
+            return _function_interfaces_
+        return None
+
     # See if the user only gave one.
     if type(ret) not in _interface_sequence_types_:
         ret = [ret]
-    real_ret = []
+
     # For each interface, walk to the root of the interface tree.
-    iim = XPTI_GetInterfaceInfoManager()
     for interface in ret:
         # Allow interface name or IID.
         interface_info = None
@@ -85,15 +103,15 @@ def _GetNominatedInterfaces(obj):
         if interface_info is None:
             # Allow a real IID
             interface_info = iim.GetInfoForIID(interface)
-        real_ret.append(interface_info.GetIID())
+        real_ret.add(interface_info.GetIID())
         parent = interface_info.GetParent()
         while parent is not None:
             parent_iid = parent.GetIID()
             if parent_iid == IID_nsISupports:
                 break
-            real_ret.append(parent_iid)
+            real_ret.add(parent_iid)
             parent = parent.GetParent()
-    return real_ret
+    return list(real_ret)
 
 ##
 ## ClassInfo support
@@ -141,6 +159,7 @@ class DefaultPolicy:
         self._obj_ = instance
         self._nominated_interfaces_ = ni = _GetNominatedInterfaces(instance)
         self._iid_ = iid
+        self._is_function_ = None # looked up lazily in _CallMethod_
         if ni is None:
             raise ValueError, "The object '%r' can not be used as a COM object" % (instance,)
         # This is really only a check for the user - the same thing is
@@ -271,10 +290,17 @@ class DefaultPolicy:
             else:
                 func(*params)
             return 0
-        else:
-            # A regular method.
-            func = getattr(self._obj_, name)
-            return 0, func(*params)
+        elif callable(self._obj_):
+            if self._is_function_ is None:
+                iim = _xpcom.XPTI_GetInterfaceInfoManager()
+                interface_info = iim.GetInfoForIID(self._iid_)
+                self._is_function_ = interface_info.GetIsFunction()
+            if self._is_function_:
+                return 0, self._obj_(*params)
+
+        # A regular method.
+        func = getattr(self._obj_, name)
+        return 0, func(*params)
 
     def _doHandleException(self, func_name, exc_info):
         try:
diff --git a/xpcom/src/PyIInterfaceInfo.cpp b/xpcom/src/PyIInterfaceInfo.cpp
--- a/xpcom/src/PyIInterfaceInfo.cpp
+++ b/xpcom/src/PyIInterfaceInfo.cpp
@@ -390,6 +390,25 @@ static PyObject *PyGetInterfaceIsArgNumb
 	return PyInt_FromLong(ret);
 }
 
+static PyObject *PyGetIsFunction(PyObject *self, PyObject *args)
+{
+	if (args && !PyArg_ParseTuple(args, ":GetIsFunction"))
+		return NULL;
+
+	nsIInterfaceInfo *pI = GetI(self);
+	if (pI==NULL)
+		return NULL;
+
+	PRBool isFunction;
+	nsresult r;
+	Py_BEGIN_ALLOW_THREADS;
+	r = pI->IsFunction(&isFunction);
+	Py_END_ALLOW_THREADS;
+	if ( NS_FAILED(r) )
+		return PyXPCOM_BuildPyException(r);
+	return PyBool_FromLong(isFunction);
+}
+
 struct PyMethodDef 
 PyMethods_IInterfaceInfo[] =
 {
@@ -408,6 +427,7 @@ PyMethods_IInterfaceInfo[] =
 	{ "GetSizeIsArgNumberForParam", PyGetSizeIsArgNumberForParam, 1},
 	{ "GetLengthIsArgNumberForParam", PyGetLengthIsArgNumberForParam, 1},
 	{ "GetInterfaceIsArgNumberForParam", PyGetInterfaceIsArgNumberForParam, 1},
+	{ "GetIsFunction", PyGetIsFunction, METH_NOARGS},
 	{NULL}
 };
 
diff --git a/xpcom/xpcom_consts.py b/xpcom/xpcom_consts.py
--- a/xpcom/xpcom_consts.py
+++ b/xpcom/xpcom_consts.py
@@ -180,11 +180,13 @@ def XPT_TDP_IS_UNIQUE_POINTER(flags): re
 def XPT_TDP_IS_REFERENCE(flags): return (flags & XPT_TDP_REFERENCE)
 
 XPT_ID_SCRIPTABLE           = 0x80
-XPT_ID_FLAGMASK             = 0x80
+XPT_ID_FUNCTION             = 0x40
+XPT_ID_FLAGMASK             = 0xc0
 XPT_ID_TAGMASK              = ~XPT_ID_FLAGMASK
 def XPT_ID_TAG(id): return id & XPT_ID_TAGMASK
 
 def XPT_ID_IS_SCRIPTABLE(flags): return flags & XPT_ID_SCRIPTABLE
+def XPT_ID_IS_FUNCTION(flags): return flags & XPT_ID_FUNCTION
 
 XPT_PD_IN       = 0x80
 XPT_PD_OUT      = 0x40
