Index: extensions/python/xpcom/__init__.py
===================================================================
RCS file: /cvsroot/mozilla/extensions/python/xpcom/__init__.py,v
retrieving revision 1.4
diff -u -r1.4 __init__.py
--- extensions/python/xpcom/__init__.py	25 Aug 2004 23:02:43 -0000	1.4
+++ extensions/python/xpcom/__init__.py	25 Apr 2007 21:48:56 -0000
@@ -48,31 +48,117 @@
     import warnings
     warnings.filterwarnings("ignore", category=FutureWarning, append=1)
 
+import os
+_location = os.path.dirname(__file__)
+
 # A global "verbose" flag - currently used by the
 # server package to print trace messages
 verbose = 0
 hr_map = {}
 
+class nsStackFrame:
+    language = 0 # what should it be?
+    languageName = "Python"
+
+    def __init__(self, tb):
+        try:
+            # magic to hook up com interface after xpcom is loaded
+            if not hasattr(nsStackFrame, "_com_interfaces_"):
+                from xpcom import components
+                nsStackFrame._com_interfaces_ = [components.interfaces.nsIStackFrame]
+        except Exception, e:
+            # not initialized yet, cannot make this an xpcom component
+            pass
+
+        self.caller = None
+
+        import linecache
+    
+        f = tb.tb_frame
+        self.lineNumber = tb.tb_lineno
+        co = f.f_code
+        self.filename = co.co_filename
+        self.name = co.co_name
+        linecache.checkcache(self.filename)
+        line = linecache.getline(self.filename, self.lineNumber)
+        if line: self.sourceLine = line.strip()
+        else: self.sourceLine = None
+
+    def toString(self):
+        return 'File "%s", line %d, in %s' % (self.filename,
+                                              self.lineNumber,
+                                              self.name)
+
 # The standard XPCOM exception object.
 # Instances of this class are raised by the XPCOM extension module.
 class Exception(exceptions.Exception):
     def __init__(self, errno, message = None):
+        exceptions.Exception.__init__(self, errno, message)
         assert int(errno) == errno, "The errno param must be an integer"
-        self.errno = errno
-        self.message = message
-        exceptions.Exception.__init__(self, errno)
-    def __str__(self):
+        try:
+            # magic to hook up com interface after xpcom is loaded
+            if not hasattr(Exception, "_com_interfaces_"):
+                import components
+                Exception._com_interfaces_ = [components.interfaces.nsIException]
+        except exceptions.Exception, e:
+            # not initialized yet, cannot make this an xpcom component
+            pass
+
         if not hr_map:
             import nsError
             for name, val in nsError.__dict__.items():
                 if type(val)==type(0):
                     hr_map[val] = name
-        message = self.message
-        if message is None:
-            message = hr_map.get(self.errno)
-            if message is None:
-                message = ""
-        return "0x%x (%s)" % (self.errno, message)
+
+        self.errno = errno
+        self.message = message
+        self.result = errno
+        self.name = hr_map.get(self.errno, "")
+        self.filename = None
+        self.lineNumber = 0
+        self.columnNumber = 0
+        self.location = None
+        self.inner = None
+        self.data = None
+
+    def setExcInfo(self, exc_info):
+        if exc_info[2]:
+            self.setStackFrame(exc_info[2])
+        
+    def setStackFrame(self, tb):
+        caller = None
+        while tb.tb_next is not None:
+            f = nsStackFrame(tb)
+            if not f.filename.startswith(_location):
+                prev_caller = caller
+                caller = f
+                caller.caller = prev_caller
+            tb = tb.tb_next
+
+        f = nsStackFrame(tb)
+        if caller and f.filename[0] == "<":
+            self.location = caller
+            self.location.caller = caller.caller
+        else:
+            self.location = f
+            self.location.caller = caller
+        self.lineNumber = f.lineNumber
+        self.filename = f.filename
+        self.name = f.name
+
+    def setData(self, exc_info):
+        import traceback
+        textObj = components.classes["@mozilla.org/supports-string;1"]\
+                .createInstance(components.interfaces.nsISupportsString)
+        textObj.data = '\n'.join(traceback.format_tb(exc_info[2]))
+        self.data = textObj;
+
+    def __str__(self):
+        if self.message is None:
+            return self.name
+        return str(self.message)
+    def toString(self):
+        return str(self)
 
 # An alias for Exception - allows code to say "from xpcom import COMException"
 # rather than "Exception" - thereby preventing clashes.
Index: extensions/python/xpcom/server/policy.py
===================================================================
RCS file: /cvsroot/mozilla/extensions/python/xpcom/server/policy.py,v
retrieving revision 1.8
diff -d -u -r1.8 policy.py
--- extensions/python/xpcom/server/policy.py	25 Aug 2004 23:02:43 -0000	1.8
+++ extensions/python/xpcom/server/policy.py	16 Mar 2007 18:16:06 -0000
@@ -133,6 +133,7 @@
     def getHelperForLanguage(self, language):
         return None # Not sure what to do here.
 
+
 class DefaultPolicy:
     def __init__(self, instance, iid):
         self._obj_ = instance
@@ -272,19 +273,70 @@
             return 0, func(*params)
 
     def _doHandleException(self, func_name, exc_info):
+        try:
+            # allow this exception to be caught in JavaScript
+            from xpcom import components
+            xs = components.classes["@mozilla.org/exceptionservice;1"].getService(components.interfaces.nsIExceptionService)
+            xm = xs.currentExceptionManager
+        except:
+            xs = xm = components = None
+
         exc_val = exc_info[1]
-        is_server_exception = isinstance(exc_val, ServerException)
-        if is_server_exception:
+        if isinstance(exc_val, (ServerException, COMException)):
             if xpcom.verbose:
                 print "** Information:  '%s' raised COM Exception %s" % (func_name, exc_val)
                 traceback.print_exception(exc_info[0], exc_val, exc_info[2])
+                print "** Message: %r : %r" % (exc_val,exc_val.toString(), )
                 print "** Returning nsresult from existing exception", exc_val
-            return exc_val.errno
-        # Unhandled exception - always print a warning.
-        print "** Unhandled exception calling '%s'" % (func_name,)
-        traceback.print_exception(exc_info[0], exc_val, exc_info[2])
-        print "** Returning nsresult of NS_ERROR_FAILURE"
-        return nsError.NS_ERROR_FAILURE
+            try:
+                # we can only unwrap python exceptions, so ignore if we
+                # cannot unwrap.
+                # Update the exception information so it is accurate, just
+                # raising Server/COMException will not have all the data
+                exc_val = xpcom.server.UnwrapObject(exc_val)
+                exc_val.setExcInfo(exc_info)
+            except ValueError, e:
+                pass
+
+            if xm and exc_val.message is None:
+                exc = xm.getCurrentException()
+                if exc:
+                    # someone we called raised an exception, so we're the
+                    # inner exception.  If we cannot modify the exception to
+                    # add ourselves as the inner, then reset the exception
+                    # to a python based class
+                    try:
+                        # we can only unwrap python exceptions, so ignore if we
+                        # cannot unwrap
+                        exc = xpcom.server.UnwrapObject(exc)
+                        exc.inner = exc_val
+                        exc_val = exc
+                    except ValueError, e:
+                        pyexec = exc_val
+                        exc_val = COMException(exc.result, exc.message)
+                        exc_val.filename = exc.filename
+                        exc_val.lineNumber = exc.lineNumber
+                        exc_val.filename = exc.filename
+                        exc_val.name = exc.name
+                        exc_val.location = exc.location
+                        exc_val.inner = pyexec
+        else:
+            # Unhandled exception - always print a warning.
+            print "** Unhandled exception calling '%s'" % (func_name,)
+            traceback.print_exception(exc_info[0], exc_val, exc_info[2])
+            print "** Returning nsresult of NS_ERROR_FAILURE"
+            if hasattr(exc_val, "__class__"):
+                message = "%s: %s" % (exc_info[1].__class__.__name__, str(exc_val))
+            else:
+                message = str(exc_val)
+            exc_val = COMException(nsError.NS_ERROR_FAILURE, message)
+            if components:
+                exc_val.setExcInfo(exc_info)
+
+        if components:
+            xs.currentExceptionManager.setCurrentException(exc_val)
+
+        return exc_val.result
 
 
     # Called whenever an unhandled Python exception is detected as a result
