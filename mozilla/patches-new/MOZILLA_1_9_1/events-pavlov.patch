Index: layout/generic/nsObjectFrame.cpp
===================================================================
RCS file: /cvsroot/mozilla/layout/generic/nsObjectFrame.cpp,v
retrieving revision 1.543
diff -u -r1.543 layout/generic/nsObjectFrame.cpp
--- layout/generic/nsObjectFrame.cpp	2 Jan 2006 15:54:24 -0000	1.543
+++ layout/generic/nsObjectFrame.cpp	20 Jan 2006 01:08:18 -0000
@@ -611,8 +621,9 @@
   return NS_OK;
 }
 
-#define EMBED_DEF_WIDTH 240
-#define EMBED_DEF_HEIGHT 200
+// XXX ActiveState
+#define EMBED_DEF_WIDTH 20
+#define EMBED_DEF_HEIGHT 20
 
 void
 nsObjectFrame::GetDesiredSize(nsPresContext* aPresContext,
@@ -2650,12 +2773,13 @@
 
 nsresult nsPluginInstanceOwner::DispatchFocusToPlugin(nsIDOMEvent* aFocusEvent)
 {
-#ifndef XP_MACOSX
+// ACTIVESTATE this fixes mousedown focus problems (bug 41310)
+//#ifndef XP_MACOSX
   if (!mPluginWindow || nsPluginWindowType_Window == mPluginWindow->type) {
     // continue only for cases without child window
     return aFocusEvent->PreventDefault(); // consume event
   }
-#endif
+//#endif
 
   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aFocusEvent));
   if (privateEvent) {
@@ -2759,16 +2883,23 @@
 /*=============== nsIKeyListener ======================*/
 nsresult nsPluginInstanceOwner::KeyDown(nsIDOMEvent* aKeyEvent)
 {
-  return DispatchKeyToPlugin(aKeyEvent);
+  return NS_OK;
+  // ActiveState: Hacks for plugin focus issues
+  //return DispatchKeyToPlugin(aKeyEvent);
 }
 
 nsresult nsPluginInstanceOwner::KeyUp(nsIDOMEvent* aKeyEvent)
 {
-  return DispatchKeyToPlugin(aKeyEvent);
+  return NS_OK;
+  // ActiveState: Hacks for plugin focus issues
+  //return DispatchKeyToPlugin(aKeyEvent);
 }
 
 nsresult nsPluginInstanceOwner::KeyPress(nsIDOMEvent* aKeyEvent)
 {
+  // ActiveState: Hacks for plugin focus issues
+  return NS_OK;
+  /*
 #ifdef XP_MACOSX // send KeyPress events only on Mac
 
   // KeyPress events are really synthesized keyDown events.
@@ -2812,12 +2943,14 @@
   }
   return NS_OK;
 #endif
+*/
 }
 
 nsresult nsPluginInstanceOwner::DispatchKeyToPlugin(nsIDOMEvent* aKeyEvent)
 {
 #ifndef XP_MACOSX
-  if (!mPluginWindow || nsPluginWindowType_Window == mPluginWindow->type)
+// ACTIVESTATE - we want this event, even though we *are* nsPluginWindowType_Window
+  if (!mPluginWindow /*|| nsPluginWindowType_Window == mPluginWindow->type*/)
     return aKeyEvent->PreventDefault(); // consume event
   // continue only for cases without child window
 #endif
@@ -2853,7 +2986,8 @@
 nsPluginInstanceOwner::MouseMove(nsIDOMEvent* aMouseEvent)
 {
 #if !defined(XP_MACOSX)
-  if (!mPluginWindow || nsPluginWindowType_Window == mPluginWindow->type)
+// ACTIVESTATE - we want this event, even though we *are* nsPluginWindowType_Window
+  if (!mPluginWindow /*|| nsPluginWindowType_Window == mPluginWindow->type*/)
     return aMouseEvent->PreventDefault(); // consume event
   // continue only for cases without child window
 #endif
@@ -2885,7 +3019,8 @@
 nsPluginInstanceOwner::MouseDown(nsIDOMEvent* aMouseEvent)
 {
 #if !defined(XP_MACOSX)
-  if (!mPluginWindow || nsPluginWindowType_Window == mPluginWindow->type)
+// ACTIVESTATE - we want this event, even though we *are* nsPluginWindowType_Window
+  if (!mPluginWindow /*|| nsPluginWindowType_Window == mPluginWindow->type*/)
     return aMouseEvent->PreventDefault(); // consume event
   // continue only for cases without child window
 #endif
@@ -3615,10 +3615,13 @@ nsresult nsPluginInstanceOwner::Dispatch
 nsresult nsPluginInstanceOwner::DispatchMouseToPlugin(nsIDOMEvent* aMouseEvent)
 {
 #if !defined(XP_MACOSX)
-  if (!mPluginWindow || nsPluginWindowType_Window == mPluginWindow->type)
+// ACTIVESTATE - we want this event, even though we *are* nsPluginWindowType_Window
+  if (!mPluginWindow /*|| nsPluginWindowType_Window == mPluginWindow->type*/)
     return aMouseEvent->PreventDefault(); // consume event
   // continue only for cases without child window
 #endif
+
+#if !defined(XP_UNIX) || defined(XP_MACOSX)
 
   // don't send mouse events if we are hidden
   if (!mWidgetVisible)
@@ -3637,7 +3640,7 @@ nsresult nsPluginInstanceOwner::Dispatch
     else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::DispatchMouseToPlugin failed, mouseEvent null");   
   }
   else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::DispatchMouseToPlugin failed, privateEvent null");   
-  
+#endif
   return NS_OK;
 }
 
@@ -3688,6 +3704,8 @@
   nsAutoString eventType;
   aEvent->GetType(eventType);
 
+// ACTIVESTATE - we want drag events, even though we *are* a plugin.
+#if 0
   if (mInstance) {
     nsCOMPtr<nsIDOMDragEvent> dragEvent = do_QueryInterface(aEvent);
     if (dragEvent) {
@@ -3696,6 +3714,8 @@
       aEvent->StopPropagation();
     }
   }
+#endif  // End ACTIVESTATE
+
   return NS_OK;
 }
 
