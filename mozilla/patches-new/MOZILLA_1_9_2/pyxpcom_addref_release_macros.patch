Index: /home/toddw/as/komodo-devel/mozilla/build/moz191-ko6.9/mozilla/extensions/python/xpcom/src/PyGBase.cpp
--- extensions/python/xpcom/src/PyGBase.cpp
+++ extensions/python/xpcom/src/PyGBase.cpp
@@ -166,12 +166,15 @@
 		PyXPCOM_GatewayWeakReference *p = (PyXPCOM_GatewayWeakReference *)(nsISupports *)m_pWeakRef;
 		p->m_pBase = nsnull;
 		m_pWeakRef = nsnull;
 	}
 }
 
+NS_IMPL_THREADSAFE_ADDREF(PyG_Base)
+NS_IMPL_THREADSAFE_RELEASE(PyG_Base)
+
 // Get the correct interface pointer for this object given the IID.
 void *PyG_Base::ThisAsIID( const nsIID &iid )
 {
 	if (this==NULL) return NULL;
 	if (iid.Equals(NS_GET_IID(nsISupports)))
 		return (nsISupports *)(nsIInternalPython *)this;
@@ -396,37 +399,12 @@
 	} // end of temp scope for Python lock - lock released here!
 	if ( !supports )
 		return NS_ERROR_NO_INTERFACE;
 	return NS_OK;
 }
 
-nsrefcnt
-PyG_Base::AddRef(void)
-{
-	nsrefcnt cnt = (nsrefcnt) PR_AtomicIncrement((PRInt32*)&mRefCnt);
-#ifdef NS_BUILD_REFCNT_LOGGING
-	// If we have no pBaseObject, then we need to ignore them
-	if (m_pBaseObject == NULL)
-		NS_LOG_ADDREF(this, cnt, refcntLogRepr, sizeof(*this));
-#endif
-	return cnt;
-}
-
-nsrefcnt
-PyG_Base::Release(void)
-{
-	nsrefcnt cnt = (nsrefcnt) PR_AtomicDecrement((PRInt32*)&mRefCnt);
-#ifdef NS_BUILD_REFCNT_LOGGING
-	if (m_pBaseObject == NULL)
-		NS_LOG_RELEASE(this, cnt, refcntLogRepr);
-#endif
-	if ( cnt == 0 )
-		delete this;
-	return cnt;
-}
-
 NS_IMETHODIMP
 PyG_Base::GetWeakReference(nsIWeakReference **ret)
 {
 	// always delegate back to the "base" gateway for the object, as this tear-off
 	// interface may not live as long as the base.  So we recurse back to the base.
 	if (m_pBaseObject) {
Index: /home/toddw/as/komodo-devel/mozilla/build/moz191-ko6.9/mozilla/extensions/python/xpcom/src/PyGWeakReference.cpp
--- extensions/python/xpcom/src/PyGWeakReference.cpp
+++ extensions/python/xpcom/src/PyGWeakReference.cpp
@@ -67,34 +67,14 @@
 	// No need to zap my gateway's reference to me, as
 	// it already holds a reference, so if we are destructing,
 	// then it can't possibly hold one.
 	m_pBase = NULL;
 }
 
-nsrefcnt
-PyXPCOM_GatewayWeakReference::AddRef(void)
-{
-	nsrefcnt cnt = (nsrefcnt) PR_AtomicIncrement((PRInt32*)&mRefCnt);
-#ifdef NS_BUILD_REFCNT_LOGGING
-	NS_LOG_ADDREF(this, cnt, refcntLogRepr, sizeof(*this));
-#endif
-	return cnt;
-}
-
-nsrefcnt
-PyXPCOM_GatewayWeakReference::Release(void)
-{
-	nsrefcnt cnt = (nsrefcnt) PR_AtomicDecrement((PRInt32*)&mRefCnt);
-#ifdef NS_BUILD_REFCNT_LOGGING
-	NS_LOG_RELEASE(this, cnt, refcntLogRepr);
-#endif
-	if ( cnt == 0 )
-		delete this;
-	return cnt;
-}
-
+NS_IMPL_THREADSAFE_ADDREF(PyXPCOM_GatewayWeakReference)
+NS_IMPL_THREADSAFE_RELEASE(PyXPCOM_GatewayWeakReference)
 NS_IMPL_THREADSAFE_QUERY_INTERFACE1(PyXPCOM_GatewayWeakReference, nsIWeakReference)
 
 NS_IMETHODIMP
 PyXPCOM_GatewayWeakReference::QueryReferent(REFNSIID iid, void * *ret)
 {
 	{ 
