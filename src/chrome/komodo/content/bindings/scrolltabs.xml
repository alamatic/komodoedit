<?xml version="1.0"?>
<!-- ***** BEGIN LICENSE BLOCK *****
 Version: MPL 1.1/GPL 2.0/LGPL 2.1
 
 The contents of this file are subject to the Mozilla Public License
 Version 1.1 (the "License"); you may not use this file except in
 compliance with the License. You may obtain a copy of the License at
 http://www.mozilla.org/MPL/
 
 Software distributed under the License is distributed on an "AS IS"
 basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 License for the specific language governing rights and limitations
 under the License.
 
 The Original Code is Komodo code.
 
 The Initial Developer of the Original Code is ActiveState Software Inc.
 Portions created by ActiveState Software Inc are Copyright (C) 2000-2007
 ActiveState Software Inc. All Rights Reserved.
 
 Contributor(s):
   ActiveState Software Inc
 
 Alternatively, the contents of this file may be used under the terms of
 either the GNU General Public License Version 2 or later (the "GPL"), or
 the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 in which case the provisions of the GPL or the LGPL are applicable instead
 of those above. If you wish to allow use of your version of this file only
 under the terms of either the GPL or the LGPL, and not to allow others to
 use your version of this file under the terms of the MPL, indicate your
 decision by deleting the provisions above and replace them with the notice
 and other provisions required by the GPL or the LGPL. If you do not delete
 the provisions above, a recipient may use your version of this file under
 the terms of any one of the MPL, the GPL or the LGPL.
 
 ***** END LICENSE BLOCK ***** -->

<!DOCTYPE bindings PUBLIC "-//MOZILLA//DTD XBL V1.0//EN" "http://www.mozilla.org/xbl">

<bindings
    xmlns="http://www.mozilla.org/xbl"
    xmlns:xbl="http://www.mozilla.org/xbl"
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

    <binding id="scrolltabsbase">
        <resources>
            <stylesheet src="chrome://komodo/skin/bindings/scrolltabs.css"/>
        </resources>
    </binding>

    <binding id="file-status-tab" display="xul:hbox"
            extends="chrome://global/content/bindings/tabbox.xml#tab">
        <resources>
            <stylesheet src="chrome://komodo/skin/bindings/scrolltabs.css"/>
        </resources>
        <content>
            <xul:hbox class="tab-image-left" xbl:inherits="selected"/>
            <xul:hbox flex="1" class="tab-image-middle" xbl:inherits="selected" align="center">
                <xul:hbox flex="0" class="tab-icons" align="center" pack="center">
                    <xul:image class="tab-icon" xbl:inherits="validate,disabled,src=action,tooltiptext=actiontip"/>
                    <xul:image class="tab-icon" xbl:inherits="validate,disabled,src=status,tooltiptext=statustip"/>
                    <xul:image class="tab-icon" xbl:inherits="validate,disabled,src=status2,tooltiptext=status2tip"/>
                    <xul:image class="tab-icon" xbl:inherits="validate,disabled,src=readonly,tooltiptext=locktip"/>
                    <xul:image class="tab-icon" xbl:inherits="validate,disabled,src=image,tooltiptext=icontip"/>
                </xul:hbox>
                <xul:label class="tab-text" xbl:inherits="value=label,accesskey,crop,disabled,selected"
                           flex="1" anonid="label" crop="right"/>
                <xul:label class="tab-text" xbl:inherits="collapsed=clean,disabled,selected"
                           collapsed="true" value="*"/>
                <xul:spacer flex="1"/>
                <xul:toolbarbutton anonid="close-button" xbl:inherits="selected"
                                   class="tab-close-button"/>
            </xul:hbox>
            <xul:hbox class="tab-image-right" xbl:inherits="selected"/>
        </content>
        <implementation>
            <method name="getTabController">
                <parameter name="tab"/>
                <body>
                <![CDATA[
                    var parent = this.parentNode;
                    while (parent) {
                      if (parent.localName == "tabbox")
                        return parent;
                      parent = parent.parentNode;
                    }
                    return null;
                ]]>
                </body>
            </method>
        </implementation>
        <handlers>
            <handler event="click" button="0" phase="capturing">
            <![CDATA[
                var anonid = event.originalTarget.getAttribute("anonid");
                if (anonid == "close-button") {
                    var panel = document.getElementById(this.linkedPanel);
                    panel.firstChild.close();
                }
            ]]>
            </handler>
            <handler event="draggesture" phase="capturing">
            <![CDATA[
                try {
                if (event.target.localName == 'tab')
                    nsDragAndDrop.startDrag(event,this.getTabController());
                } catch(e) {/*let the event bubble*/}
            ]]>
            </handler>
            <handler event="dragdrop" phase="capturing">
            <![CDATA[
                try {
                if (nsDragAndDrop.mDragService.getCurrentSession().sourceNode)
                    nsDragAndDrop.drop(event,this.getTabController());
                } catch(e) {/*let the event bubble*/}
            ]]>
            </handler>
            <handler event="dragenter" phase="capturing">
            <![CDATA[
                try {
                if (nsDragAndDrop.mDragService.getCurrentSession().sourceNode)
                    nsDragAndDrop.dragEnter(event,this.getTabController());
                } catch(e) {/*let the event bubble*/}
            ]]>
            </handler>
            <handler event="dragexit" phase="capturing">
            <![CDATA[
                try {
                if (nsDragAndDrop.mDragService.getCurrentSession().sourceNode)
                    nsDragAndDrop.dragExit(event,this.getTabController());
                } catch(e) {/*let the event bubble*/}
            ]]>
            </handler>
            <handler event="dragover" phase="capturing">
            <![CDATA[
                try {
                if (nsDragAndDrop.mDragService.getCurrentSession().sourceNode)
                    nsDragAndDrop.dragOver(event,this.getTabController());
                } catch(e) {/*let the event bubble*/}
            ]]>
            </handler>
        </handlers>
    </binding>

    <!-- This is bound to <tabs type="sidebar">, and currently used for
         Komodo's side and bottom panes. -->
    <binding id="tabs-droplist" xbl:inherits="orient"
             extends="chrome://global/content/bindings/tabbox.xml#tabs">
        <content>
            <xul:box xbl:inherits="orient,align,pack,dir" flex="1"
                     align="center" pack="center">
            <xul:label anonid="label" class="tab-text" xbl:inherits="value=label"/>
            <xul:spacer flex="1"/>
            <xul:hbox class="noborder sidebar-buttons">
            <xul:toolbarbutton anonid="tabs-list"
                           type="menu"
                           persist="buttonstyle"
                           buttonstyle="pictures"
                           class="tabs-select-button"
                           oncommand="this.firstChild.showPopup(this, -1,-1);">
                <xul:menupopup anonid="tabs-list-popup"
                    onpopupshowing="this.parentNode.parentNode.parentNode.parentNode.getTabList();"/>
            </xul:toolbarbutton>
            <xul:toolbarbutton anonid="panel-close-button" class="tabs-closebutton"
                        collapsed="true"
                        xbl:inherits="onclick=onclose,
                                      collapsed=closecollapsed,
                                      disabled=closedisabled"/>
            </xul:hbox>
            <xul:box anonid="left-scroll" collapsed="true" flex="0">
                <children includes="tab"/>
            </xul:box>
            </xul:box>
        </content>
        <implementation>
            <property name="menuListPopup" readonly="true"
                onget="return document.getAnonymousElementByAttribute(this,'anonid','tabs-list-popup');"/>

            <method name="_createMenuItem">
                <parameter name="tab"/>
                <body>
                <![CDATA[
                try {
                    var menuitem = document.createElement('menuitem');
                    menuitem.setAttribute("label", tab.label);
                    menuitem.setAttribute('type', 'checkbox');
                    if (tab.selected) {
                        menuitem.setAttribute('checked', 'true');
                        // No need to switch view oncommand, this view is already current.
                        // However we *do* need to ensure that the checkmark stays.
                        // See http://bugs.activestate.com/show_bug.cgi?id=26423
                        menuitem.setAttribute('oncommand',
                                              'event.target.setAttribute("checked", "true");');
                    } else {
                        menuitem.setAttribute('checked', 'false');
                        menuitem.setAttribute('oncommand', 'this.tab.control.selectedItem = this.tab;');
                    }
                    menuitem.tab = tab;
                    return menuitem;
                } catch(ex) {
                    var _log = ko.logging.getLogger("scrolltabs");
                    _log.exception(ex, "error generating Window list "+
                                                "menuitem for '"+tab.label+"'");
                }
                return null;
                ]]>
                </body>
            </method>

            <method name="getTabList">
                <parameter name="dir"/>
                <body>
                <![CDATA[
                var popup = this.menuListPopup;
                while (popup.lastChild) {
                    popup.removeChild(popup.lastChild);
                }
        
                // get all the tab labels, and create the menu
                var child;
                for (var i = 0; i < this.childNodes.length; i++) {
                    child = this.childNodes[i];
                    if (child.localName == "tab" &&
                        (!child.hasAttribute("collapsed") || child.getAttribute("collapsed") == false) &&
                        (!child.hasAttribute("hidden") || child.getAttribute("hidden") == false)) {
                        popup.appendChild(this._createMenuItem(this.childNodes[i]));
                    }
                }
                ]]>
                </body>
            </method>
        </implementation>
        <handlers>
            <handler event="select" phase="capturing">
            <![CDATA[
                this.setAttribute("label", selectedItem.label);
            ]]>
            </handler>
        </handlers>
    </binding>

    <binding id="tabs-scrollable" xbl:inherits="orient"
            extends="chrome://global/content/bindings/tabbox.xml#tabs">
        <resources>
            <stylesheet src="chrome://komodo/skin/bindings/buttons.css"/>
            <stylesheet src="chrome://komodo/skin/bindings/scrolltabs.css"/>
        </resources>
        <content>
            <xul:box xbl:inherits="orient,align,pack,dir,overflow" flex="1" class="tabstrip-box" orient="horizontal">
                <xul:arrowscrollbox anonid="tabstrip" xbl:inherits="orient,align,pack,dir"
                    class="tab-arrowscrollbox" flex="1" clicktoscroll="true">
                    <children includes="tab"/>
                </xul:arrowscrollbox>
                <children/>
                <xul:toolbarbutton anonid="tabs-list"
                               type="menu"
                               persist="buttonstyle"
                               buttonstyle="pictures"
                               class="tabs-select-button"
                               oncommand="this.firstChild.showPopup(this, -1,-1);">
                    <xul:menupopup anonid="tabs-list-popup" position="after_end"
                        onpopupshowing="this.parentNode.parentNode.parentNode.getTabList();"/>
                </xul:toolbarbutton>
                <xul:toolbarbutton anonid="panel-close-button" class="tabs-closebutton"
                            collapsed="true"
                            xbl:inherits="onclick=onclose,
                                          collapsed=closecollapsed,
                                          disabled=closedisabled,
                                          selected"/>
            </xul:box>
        </content>

        <implementation>
            <field name="_repeater">null</field>
            <field name="_scrollbox">null</field>

            <property name="scrollbox" readonly="true"
                onget="return document.getAnonymousElementByAttribute(this,'anonid','tabstrip');"/>

            <property name="scrollBoxObject" readonly="true"
                onget="return this.scrollbox.scrollBoxObject.QueryInterface(Components.interfaces.nsIScrollBoxObject);"/>

            <property name="menuListPopup" readonly="true"
                onget="return document.getAnonymousElementByAttribute(this,'anonid','tabs-list-popup');"/>

            <method name="_createMenuItem">
                <parameter name="tab"/>
                <body>
                <![CDATA[
                try {
                    var menuitem = document.createElement('menuitem');
                    menuitem.setAttribute("label", tab.label);
                    menuitem.setAttribute('type', 'checkbox');
                    if (tab.selected) {
                        menuitem.setAttribute('checked', 'true');
                        // No need to switch view oncommand, this view is already current.
                        // However we *do* need to ensure that the checkmark stays.
                        // See http://bugs.activestate.com/show_bug.cgi?id=26423
                        menuitem.setAttribute('oncommand',
                                              'event.target.setAttribute("checked", "true");');
                    } else {
                        menuitem.setAttribute('checked', 'false');
                        menuitem.setAttribute('oncommand', 'this.tab.control.selectedItem = this.tab;');
                    }
                    menuitem.tab = tab;
                    return menuitem;
                } catch(ex) {
                    var _log = ko.logging.getLogger("scrolltabs");
                    _log.exception(ex, "error generating Window list "+
                                                "menuitem for '"+tab.label+"'");
                }
                return null;
                ]]>
                </body>
            </method>


            <method name="getTabList">
                <parameter name="dir"/>
                <body>
                <![CDATA[
                var popup = this.menuListPopup;
                while (popup.lastChild) {
                    popup.removeChild(popup.lastChild);
                }
        
                // get all the tab labels, and create the menu
                var child;
                for (var i = 0; i < this.childNodes.length; i++) {
                    child = this.childNodes[i];
                    if (child.localName == "tab" &&
                        (!child.hasAttribute("collapsed") || child.getAttribute("collapsed") == false) &&
                        (!child.hasAttribute("hidden") || child.getAttribute("hidden") == false)) {
                        popup.appendChild(this._createMenuItem(this.childNodes[i]));
                    }
                }
                ]]>
                </body>
            </method>

            <method name="advanceSelectedTab">
                <parameter name="aDir"/>
                <body>
                <![CDATA[
                // XXX copied from mozilla's tabbox.xml and modified to make
                // sure that non-tab children are not selected on ctrl-tab
                var startTab = this.selectedItem;
                var next = startTab[aDir == -1 ? "previousSibling" : "nextSibling"];

                while (next != startTab && (!next || (next.getAttribute("hidden") || next.localName != 'tab'))) {
                  if (next && (next.getAttribute("hidden") || next.localName != 'tab'))
                    next = next[aDir == -1 ? "previousSibling" : "nextSibling"];
                  if (!next)
                    next = aDir == 1 ? this.childNodes[0] : this.childNodes[this.childNodes.length - 1];
                }

                if (next && next != startTab) {
                  this.selectedItem = next;
                  if (this.getAttribute("setfocus") != "false") {
                    next.focus();
                    document.commandDispatcher.advanceFocusIntoSubtree(next);
                  }
                }
                ]]>
                </body>
            </method>

            <method name="scrollToTabIndex">
                <parameter name="index"/>
                <body>
                <![CDATA[
                    if (index >= 0 && index < this.childNodes.length) {
                        this.scrollBoxObject.ensureElementIsVisible(this.childNodes[index]);
                    }
                ]]>
                </body>
            </method>
        </implementation>
        <handlers>
            <handler event="underflow" phase="capturing">
            <![CDATA[
                this.removeAttribute("overflow");
                this.scrollBoxObject.scrollTo(0, 0)
            ]]>
            </handler>

            <handler event="overflow" phase="capturing">
            <![CDATA[
                this.setAttribute("overflow", "true");
                this.scrollBoxObject.ensureElementIsVisible(this.selectedItem);
            ]]>
            </handler>

            <handler event="select" phase="capturing">
            <![CDATA[
                this.scrollBoxObject.ensureElementIsVisible(this.selectedItem);
            ]]>
            </handler>
            <handler event="mousedown" phase="capturing">
            <![CDATA[
                // force a tab switch on mousedown so we always focus the
                // tabpanel, and cause a select event for the tab
                if (event.button != 1 && event.originalTarget.localName == 'tab') {
                    // set the selected item.  If the currently selected item
                    // is also the originalTarget, we'll 'selected' will be
                    // reset to true, and a select event will be issued.
                    this.selectedItem = event.originalTarget;
                }
            ]]>
            </handler>
        </handlers>
    </binding>

    <!-- Used clues from tabBindings.xul -->
    <binding id="tabbox-draggable" xbl:inherits="orient"
        extends="chrome://global/content/bindings/tabbox.xml#tabbox">
        <content>
            <xul:hbox class="tab-drop-indicator-bar" anonid="drop-indicator-bar" collapsed="true">
                <xul:hbox class="tab-drop-indicator" mousethrough="always"/>
            </xul:hbox>
            <children/>
        </content>
        <implementation>
            <field name="_lastTarget">-1</field>
            <field name="dropIndicatorBar">
              document.getAnonymousElementByAttribute(this, "anonid", "drop-indicator-bar");
            </field>

            <method name="getTabIndexById">
                <parameter name="id"/>
                <body>
                <![CDATA[
                    for(var i = 0; i < this._tabs.childNodes.length; i++) {
                        if(this._tabs.childNodes[i].getAttribute('id') == id) {
                            return i;
                        }
                    }
                    return -1;
                ]]>
                </body>
            </method>

            <method name="getTabById">
                <parameter name="id"/>
                <body>
                <![CDATA[
                    for (var i = 0; i < this._tabs.childNodes.length; i++) {
                        if (this._tabs.childNodes[i].getAttribute('id') == id)
                            return this._tabs.childNodes[i];
                    }
                    return null;
                ]]>
                </body>
            </method>

            <method name="getTabIdByIndex">
                <parameter name="index"/>
                <body>
                <![CDATA[
                    if(index >= 0 && index < this._tabs.childNodes.length) {
                        return this._tabs.childNodes[index].getAttribute('id');
                    }
                    return "";
                ]]>
                </body>
            </method>

            <method name="advanceSelectedTab">
                <parameter name="dir"/>
                <body>
                    <![CDATA[
                    this._tabs.advanceSelectedTab(dir, true);
                    ]]>
                </body>
            </method>
            
            <method name="getTabController">
                <parameter name="tab"/>
                <body>
                <![CDATA[
                    var parent = tab.parentNode;
                    while (parent) {
                      if (parent.localName == "tabbox")
                        return parent;
                      parent = parent.parentNode;
                    }
                    return null;
                ]]>
                </body>
            </method>

            <field name="getDragData">null</field>
            <method name="onDragStart">
                <parameter name="event"/>
                <parameter name="transferData"/>
                <parameter name="action"/>
                <body>
                <![CDATA[
                    var tabid = event.target.getAttribute('id');
                    var draggedIndex = this.getTabIndexById(tabid);
                    var tabpanel = document.getElementById(event.target.linkedPanel);
                    transferData.data=new TransferData();
                    if ('getURI' in tabpanel.firstChild) {
                        var uri = tabpanel.firstChild.getURI();
                        if (uri) {
                            var title = null;
                            var moz_url = uri;
                            if ('title' in tabpanel.firstChild) {
                                title = tabpanel.firstChild.title;
                            }
                            if (title &&
                                uri.indexOf(title) < 0 &&
                                title != '(untitled)') {
                                moz_url = uri + '\n' + title;
                            }
                            transferData.data.addDataForFlavour("text/x-moz-url",moz_url);
                            transferData.data.addDataForFlavour("text/unicode",uri);
                        }
                    }
                    transferData.data.addDataForFlavour("text/x-tabid",tabid);
                ]]>
                </body>
            </method>

            <method name="getSupportedFlavours">
                <body>
                <![CDATA[
                    var flavours = new FlavourSet();
                    flavours.appendFlavour("text/x-tabid");
                    return flavours;
                ]]>
                </body>
            </method>

            <method name="canDrop">
                <parameter name="event"/>
                <parameter name="session"/>
                <body>
                <![CDATA[
                    if (!session.sourceNode ||
                        session.sourceNode.localName != 'tab') return false;

                    // If this is a different window, then need to ask the
                    // view if moving to a another window is okay.
                    if (session.sourceNode.ownerDocument != document) {
                        var sourceTabbox = this.getTabController(session.sourceNode);
                        var sourceView = sourceTabbox.parentNode.currentView;
                        if (!sourceView.canBeOpenedInAnotherWindow()) {
                            return false;
                        }
                    }
                    
                    var el = session.sourceNode;
                    while (el && el != this) {
                        if (el.localName == 'tabs') return true;
                        el = el.parentNode;
                    }
                    return false;
                ]]>
                </body>
            </method>

            <field name="_dropTimeout">null</field>
            <method name="onDrop">
            <parameter name="event"/>
            <parameter name="dropData"/>
            <parameter name="session"/>
            <body><![CDATA[
                if (!session.canDrop
                    || session.sourceNode.localName != 'tab')
                {
                    return false;
                }

                // Dropping tab onto self: nothing to do.
                if (session.sourceNode.id == event.target.id) {
                    return true;
                }
                
                // Handle the drop asynchronously.
                // [Not sure this is necessary --TM.]
                targetNode = (event.originalTarget.localName == 'tab'
                              ? event.originalTarget : event.target);
                this._dropTimeout = new objectTimer(
                    this, this._doDropAsync,
                    [session.sourceNode, targetNode, event]);
                this._dropTimeout.startTimeout(1);

                event.cancelBubble = true;
                return true;
            ]]></body>
            </method>

            <method name="_doDropAsync">
            <parameter name="sourceNode"/>
            <parameter name="targetNode"/>
            <parameter name="event"/>
            <body><![CDATA[
                var sourceTabbox = this.getTabController(sourceNode);
                var targetTabbox = this;
                var sourceIndex = sourceTabbox.getTabIndexById(sourceNode.id);
                var targetIndex = targetTabbox.getNewIndex(event);
                //dump("move tab at sourceIndex="+sourceIndex
                //     +" (sourceTabbox "+sourceTabbox.parentNode.getAttribute("id")
                //     +") to targetIndex="+targetIndex
                //     +" (targetTabbox "+targetTabbox.parentNode.getAttribute("id")
                //     +")\n");
            
                if (sourceNode.ownerDocument != document) {
                    // 1. Moving a tab from one Komodo window to another.
                    var sourceView = sourceTabbox.parentNode.currentView;
                    
                    // Gather the data we need to open the view in the
                    // target window.
                    var uri = sourceView.document.file.URI;
                    var viewType = sourceView.getAttribute("type");
                    var line = (viewType == "editor" ? sourceView.currentLine : null);
                    var viewList = targetTabbox.parentNode;
                    
                    // Close the source view first to ensure unsaved
                    // changes, etc. get handled first.
                    if (!sourceView.close()) {
                        return;
                    }
                    
                    // Open the new view.
                    if (line != null) {
                        ko.views.manager.doFileOpenAtLine(
                            uri, line, viewType, viewList, targetIndex);
                    } else {
                        ko.views.manager.doFileOpen(
                            uri, viewType, viewList, targetIndex);
                    }
                    window.focus();
                } else if (sourceTabbox != targetTabbox) {
                    // 2. Moving to the other view-tabbed tab box in the
                    //    same Komodo window.
                    var sourceView = sourceTabbox.parentNode.currentView;
                    ko.views.manager.topView.moveView(sourceView, targetIndex);
                } else {
                    // 3. Moving within the same view-tabbed tab box.
                    if (targetIndex - sourceIndex == 1) {
                        // We are dragging the tab to just after itself: no-op.
                    } else if (targetNode.localName == 'tab') {
                        var targetTab = targetTabbox._tabs.childNodes[targetIndex];
                        targetTabbox._tabs.insertBefore(sourceNode, targetTab);
                    } else { // targetNode.localName == 'tabs'
                        // Inserting at end of the tabs.
                        targetTabbox._tabs.appendChild(sourceNode);
                    }
                }

                this._lastTarget = -1;
            ]]></body>
            </method>

            <method name="onDragEnter">
                <parameter name="event"/>
                <parameter name="session"/>
                <body>
                <![CDATA[
                    if (event.target.localName=='tab' &&
                        session.sourceNode &&
                        session.sourceNode.localName=='tab' &&
                        event.target != session.sourceNode) {
                        event.target.setAttribute('dragtarget','true');
                        var targetIndex = this.getTabIndexById(event.target.id);
                        if (this._lastTarget < 0) this._lastTarget = targetIndex;
                        if (this._tabs.getAttribute('type')=='scrollable') {
                            var targetTab = this._tabs.childNodes[targetIndex];
                            if (targetIndex < this._tabs.childNodes.length-1 && targetIndex > this._lastTarget) {
                                this._tabs.scrollBoxObject.ensureElementIsVisible(targetTab.nextSibling);
                            } else if (targetIndex > 0 && targetIndex < this._lastTarget) {
                                this._tabs.scrollBoxObject.ensureElementIsVisible(targetTab.previousSibling);
                            }
                            this._tabs.scrollBoxObject.ensureElementIsVisible(targetTab);
                        }
                        // if esc is pressed while dragging, we do not
                        // get a dragexit call.  this timer will unset
                        // the target style in that situation
                        event.target._repeater = new objectTimer(event.target,event.target.removeAttribute,['dragtarget']);
                        event.target._repeater.startTimeout(1000);
                    }
                    return true;
                ]]>
                </body>
            </method>

            <method name="getNewIndex">
              <parameter name="aEvent"/>
              <body>
                <![CDATA[
                  var i;
                  var tabs = this._tabs.childNodes;
                  if (window.getComputedStyle(this.parentNode, null).direction == "ltr") {
                    for (i = aEvent.target.localName == "tab" ? aEvent.target._tPos : 0; i < tabs.length; i++)
                      if (aEvent.screenX < tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2) 
                        return i;
                  } else {
                    for (i = aEvent.target.localName == "tab" ? aEvent.target._tPos : 0; i < tabs.length; i++)
                      if (aEvent.screenX > tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2)
                        return i;
                  }
                  return tabs.length;
                ]]>
              </body>
            </method>

            <method name="onDragOver">
                <parameter name="event"/>
                <parameter name="flavour"/>
                <parameter name="session"/>
                <body>
                <![CDATA[
                var tabStrip = this._tabs.scrollbox;
                var ltr = (window.getComputedStyle(this.parentNode, null).direction
                           == "ltr");
    
                // autoscroll the tab strip if we drag over the scroll
                // buttons, even if we aren't dragging a tab, but then
                // return to avoid drawing the drop indicator
                var pixelsToScroll = 0;
                if (this._tabs.getAttribute("overflow") == "true") {
                  var targetAnonid = event.originalTarget.getAttribute("anonid");
                  switch (targetAnonid) {
                    case "scrollbutton-up":
                      pixelsToScroll = tabStrip.scrollIncrement * -1;
                      break;
                    case "scrollbutton-down":
                    case "tabs-list":
                      pixelsToScroll = tabStrip.scrollIncrement;
                      break;
                  }
                  if (pixelsToScroll)
                    tabStrip.scrollByPixels((ltr ? 1 : -1) * pixelsToScroll);
                }
    
                var newIndex = this.getNewIndex(event);
                var ib = this.dropIndicatorBar;
                var ind = ib.firstChild;
                var tabStripBoxObject = this._tabs.scrollBoxObject;
                var tabs = this._tabs.childNodes;
                var minMargin = tabStripBoxObject.x - this.boxObject.x;
                // make sure we don't place the tab drop indicator past the
                // edge, or the containing box will flex and stretch
                // the tab drop indicator bar, which will flex the url bar.  
                // XXX todo
                // just use first value if you can figure out how to get
                // the tab drop indicator to crop instead of flex and stretch
                // the tab drop indicator bar.
                var maxMargin = Math.min(minMargin + tabStripBoxObject.width, 
                                         ib.boxObject.x + ib.boxObject.width -
                                         ind.boxObject.width);
                if (!ltr)
                  [minMargin, maxMargin] = [this.boxObject.width - maxMargin,
                                            this.boxObject.width - minMargin];
                var newMargin, tabBoxObject;
                if (pixelsToScroll) {
                  // if we are scrolling, put the drop indicator at the edge
                  // so that it doesn't jump while scrolling
                  newMargin = (pixelsToScroll > 0) ? maxMargin : minMargin;
                }
                else {
                  if (newIndex == tabs.length) {
                    tabBoxObject =  tabs[newIndex-1].boxObject;
                    if (ltr)
                      newMargin = tabBoxObject.screenX - this.boxObject.screenX
                                  + tabBoxObject.width;
                    else
                      newMargin = this.boxObject.screenX - tabBoxObject.screenX
                                  + this.boxObject.width;
                  }
                  else {
                    tabBoxObject =  tabs[newIndex].boxObject;
                    if (ltr)
                      newMargin = tabBoxObject.screenX - this.boxObject.screenX;
                    else
                      newMargin = this.boxObject.screenX - tabBoxObject.screenX
                                  + this.boxObject.width - tabBoxObject.width;
                  }
                  // ensure we never place the drop indicator beyond our limits
                  if (newMargin < minMargin)
                    newMargin = minMargin;
                  else if (newMargin > maxMargin)
                    newMargin = maxMargin;
                }
    
                ind.style.MozMarginStart = newMargin + 'px';
    
                ib.collapsed = false;
                return true;
                ]]>
                </body>
            </method>

            <method name="onDragExit">
                <parameter name="event"/>
                <parameter name="session"/>
                <body>
                <![CDATA[
                    if (event.target.localName=='tab') {
                        this._lastTarget = this.getTabIndexById(event.target.id);
                        event.target.removeAttribute('dragtarget');
                    }
                    this.dropIndicatorBar.collapsed = true;
                    return true;
                ]]>
                </body>
            </method>

        </implementation>
        <handlers>
            <handler event="draggesture" phase="bubbling">
            <![CDATA[
                try {
                if (event.target.localName == 'tab' &&
                        event.target.parentNode.parentNode == this)
                    nsDragAndDrop.startDrag(event,this);
                } catch(e) {/*let the event bubble*/}
            ]]>
            </handler>
            <handler event="dragdrop" phase="bubbling">
            <![CDATA[
                try {
                if (nsDragAndDrop.mDragService.getCurrentSession().sourceNode)
                    nsDragAndDrop.drop(event,this);
                } catch(e) {/*let the event bubble*/}
            ]]>
            </handler>
            <handler event="dragenter" phase="capturing">
            <![CDATA[
                try {
                if (nsDragAndDrop.mDragService.getCurrentSession().sourceNode)
                    nsDragAndDrop.dragEnter(event,this);
                } catch(e) {/*let the event bubble*/}
            ]]>
            </handler>
            <handler event="dragexit" phase="capturing">
            <![CDATA[
                try {
                if (nsDragAndDrop.mDragService.getCurrentSession().sourceNode)
                    nsDragAndDrop.dragExit(event,this);
                } catch(e) {/*let the event bubble*/}
            ]]>
            </handler>
            <handler event="dragover" phase="capturing">
            <![CDATA[
                try {
                if (nsDragAndDrop.mDragService.getCurrentSession().sourceNode)
                    nsDragAndDrop.dragOver(event,this);
                } catch(e) {/*let the event bubble*/}
            ]]>
            </handler>
        </handlers>
    </binding>

</bindings>
