<?xml version="1.0"?>
<!-- ***** BEGIN LICENSE BLOCK *****
 Version: MPL 1.1/GPL 2.0/LGPL 2.1
 
 The contents of this file are subject to the Mozilla Public License
 Version 1.1 (the "License"); you may not use this file except in
 compliance with the License. You may obtain a copy of the License at
 http://www.mozilla.org/MPL/
 
 Software distributed under the License is distributed on an "AS IS"
 basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 License for the specific language governing rights and limitations
 under the License.
 
 The Original Code is Komodo code.
 
 The Initial Developer of the Original Code is ActiveState Software Inc.
 Portions created by ActiveState Software Inc are Copyright (C) 2000-2007
 ActiveState Software Inc. All Rights Reserved.
 
 Contributor(s):
   ActiveState Software Inc
 
 Alternatively, the contents of this file may be used under the terms of
 either the GNU General Public License Version 2 or later (the "GPL"), or
 the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 in which case the provisions of the GPL or the LGPL are applicable instead
 of those above. If you wish to allow use of your version of this file only
 under the terms of either the GPL or the LGPL, and not to allow others to
 use your version of this file under the terms of the MPL, indicate your
 decision by deleting the provisions above and replace them with the notice
 and other provisions required by the GPL or the LGPL. If you do not delete
 the provisions above, a recipient may use your version of this file under
 the terms of any one of the MPL, the GPL or the LGPL.
 
 ***** END LICENSE BLOCK ***** -->

<!DOCTYPE bindings PUBLIC "-//MOZILLA//DTD XBL V1.0//EN" "http://www.mozilla.org/xbl" [
  <!ENTITY % bindingsDTD SYSTEM "chrome://komodo/locale/bindings.dtd">
  %bindingsDTD;
]>

<bindings
    xmlns="http://www.mozilla.org/xbl"
    xmlns:xbl="http://www.mozilla.org/xbl"
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

    <binding id="file-status-tab" display="xul:hbox"
            extends="chrome://global/content/bindings/tabbox.xml#tab">
        <content>
            <xul:hbox class="tab-image-left" xbl:inherits="selected"/>
            <xul:hbox flex="1" class="tab-image-middle" xbl:inherits="selected" align="center">
                <xul:hbox flex="0" class="tab-icons" align="center" pack="center">
                    <xul:image class="tab-icon" xbl:inherits="validate,disabled,src=action,tooltiptext=actiontip"/>
                    <xul:image class="tab-icon" xbl:inherits="validate,disabled,src=status,tooltiptext=statustip"/>
                    <xul:image class="tab-icon" xbl:inherits="validate,disabled,src=status2,tooltiptext=status2tip"/>
                    <xul:image class="tab-icon" xbl:inherits="validate,disabled,src=readonly,tooltiptext=locktip"/>
                    <xul:image class="tab-icon" xbl:inherits="validate,disabled,src=image,tooltiptext=icontip"/>
                </xul:hbox>
                <xul:label class="tab-text" xbl:inherits="value=label,accesskey,crop,disabled,selected"
                           flex="1" anonid="label" crop="right"/>
                <xul:label class="tab-text" xbl:inherits="collapsed=clean,disabled,selected"
                           collapsed="true" value="*"/>
                <xul:spacer flex="1"/>
                <xul:toolbarbutton anonid="close-button" xbl:inherits="selected"
                                   class="tab-close-button"/>
            </xul:hbox>
            <xul:hbox class="tab-image-right" xbl:inherits="selected"/>
        </content>
        <implementation>
            <method name="getTabController">
                <parameter name="tab"/>
                <body>
                <![CDATA[
                    var parent = this.parentNode;
                    while (parent) {
                      if (parent.localName == "tabbox")
                        return parent;
                      parent = parent.parentNode;
                    }
                    return null;
                ]]>
                </body>
            </method>
        </implementation>
        <handlers>
            <handler event="click" button="0" phase="capturing">
            <![CDATA[
                var anonid = event.originalTarget.getAttribute("anonid");
                if (anonid == "close-button") {
                    var panel = document.getElementById(this.linkedPanel);
                    panel.firstChild.close();
                    event.stopPropagation();
                }
            ]]>
            </handler>
        </handlers>
    </binding>

    <!-- This is bound to <tabs type="sidebar">, and currently used for
         Komodo's side panes. -->
    <binding id="tabs-droplist" xbl:inherits="orient"
             extends="chrome://global/content/bindings/tabbox.xml#tabs">
        <content>
            <xul:box xbl:inherits="orient,align,pack,dir" flex="1"
                     align="center" pack="center">
                <xul:label anonid="label" class="tab-text" xbl:inherits="value=label"/>
                <xul:spacer flex="1"/>
                <xul:hbox class="noborder sidebar-buttons">
                    <xul:toolbarbutton anonid="tabs-list"
                            type="menu"
                            persist="buttonstyle"
                            buttonstyle="pictures"
                            class="tabs-select-button"
                            tooltiptext="&listAllSidebars.tooltiptext;">
                        <xul:menupopup anonid="tabs-list-popup"
                                onpopupshowing="document.getBindingParent(this).getTabList();"/>
                    </xul:toolbarbutton>
                    <xul:toolbarbutton anonid="panel-close-button"
                            class="tabs-closebutton"
                            collapsed="true"
                            xbl:inherits="onclick=onclose,collapsed=closecollapsed,disabled=closedisabled"/>
                </xul:hbox>
                <xul:box anonid="left-scroll" collapsed="true" flex="0">
                    <children includes="tab"/>
                </xul:box>
            </xul:box>
        </content>
        <implementation>
            <property name="menuListPopup" readonly="true"
                onget="return document.getAnonymousElementByAttribute(this,'anonid','tabs-list-popup');"/>

            <method name="_createMenuItem">
                <parameter name="tab"/>
                <body>
                <![CDATA[
                try {
                    var menuitem = document.createElement('menuitem');
                    menuitem.setAttribute("label", tab.label);
                    menuitem.setAttribute('type', 'checkbox');
                    if (tab.selected) {
                        menuitem.setAttribute('checked', 'true');
                        // No need to switch view oncommand, this view is already current.
                        // However we *do* need to ensure that the checkmark stays.
                        // See http://bugs.activestate.com/show_bug.cgi?id=26423
                        menuitem.setAttribute('oncommand',
                                              'event.target.setAttribute("checked", "true");');
                    } else {
                        menuitem.setAttribute('checked', 'false');
                        menuitem.setAttribute('oncommand', 'this.tab.control.selectedItem = this.tab;');
                    }
                    menuitem.tab = tab;
                    return menuitem;
                } catch(ex) {
                    var _log = ko.logging.getLogger("scrolltabs");
                    _log.exception(ex, "error generating Window list "+
                                                "menuitem for '"+tab.label+"'");
                }
                return null;
                ]]>
                </body>
            </method>

            <method name="getTabList">
                <parameter name="dir"/>
                <body>
                <![CDATA[
                var popup = this.menuListPopup;
                while (popup.lastChild) {
                    popup.removeChild(popup.lastChild);
                }
        
                // get all the tab labels, and create the menu
                var child;
                for (var i = 0; i < this.childNodes.length; i++) {
                    child = this.childNodes[i];
                    if (child.localName == "tab" &&
                        (!child.hasAttribute("collapsed") || child.getAttribute("collapsed") == false) &&
                        (!child.hasAttribute("hidden") || child.getAttribute("hidden") == false)) {
                        popup.appendChild(this._createMenuItem(child));
                    }
                }
                ]]>
                </body>
            </method>
        </implementation>
        <handlers>
            <handler event="select" phase="capturing">
            <![CDATA[
                this.setAttribute("label", selectedItem.label);
            ]]>
            </handler>
        </handlers>
    </binding>

    <binding id="tabs-scrollable" xbl:inherits="orient"
            extends="chrome://global/content/bindings/tabbox.xml#tabs">
        <content>
            <xul:box xbl:inherits="orient,align,pack,dir,overflow" flex="1" class="tabstrip-box" orient="horizontal">
                <xul:arrowscrollbox anonid="tabstrip" xbl:inherits="orient,align,pack,dir"
                    class="tab-arrowscrollbox" flex="1" clicktoscroll="true">
                    <children includes="tab"/>
                </xul:arrowscrollbox>
                <children/>
                <xul:toolbarbutton anonid="tabs-list"
                               type="menu"
                               persist="buttonstyle"
                               buttonstyle="pictures"
                               class="tabs-select-button"
                               tooltiptext="&listAllTabs.tooltiptext;">
                    <xul:menupopup anonid="tabs-list-popup" position="after_end"
                        onpopupshowing="document.getBindingParent(this).getTabList();"/>
                </xul:toolbarbutton>
                <xul:toolbarbutton anonid="panel-close-button" class="tabs-closebutton"
                            collapsed="true"
                            xbl:inherits="onclick=onclose,
                                          collapsed=closecollapsed,
                                          disabled=closedisabled,
                                          selected"/>
            </xul:box>
        </content>

        <implementation>
            <field name="_repeater">null</field>
            <field name="_scrollbox">null</field>

            <property name="scrollbox" readonly="true"
                onget="return document.getAnonymousElementByAttribute(this,'anonid','tabstrip');"/>

            <property name="scrollBoxObject" readonly="true"
                onget="return this.scrollbox.scrollBoxObject.QueryInterface(Components.interfaces.nsIScrollBoxObject);"/>

            <property name="menuListPopup" readonly="true"
                onget="return document.getAnonymousElementByAttribute(this,'anonid','tabs-list-popup');"/>

            <method name="_createMenuItem">
                <parameter name="tab"/>
                <body>
                <![CDATA[
                try {
                    const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
                    var menuitem = document.createElementNS(XUL_NS, "menuitem");
                    menuitem.setAttribute('crop', 'center');
                    
                    var label = null, tooltiptext;
                    if (tab.linkedPanel) {
                        // Bug 82850 -- only editor tabs have a linked panel with
                        // associated document info.  Tabs in other panes, like the
                        // toolbox, usually don't.
                        try {
                            var view = document.getElementById(tab.linkedPanel).firstChild;
                            [label, tooltiptext] = ko.views.labelsFromView(view, null, true);
                        } catch (ex) {
                            var _log = ko.logging.getLogger("scrolltabs");
                            _log.exception("error calculating tab label '"+label+"': "+ex+"\n");
                        }
                    }
                    if (!label) {
                        tooltiptext = label = tab.label;
                    }
                    menuitem.setAttribute("label", label);
                    menuitem.setAttribute("tooltiptext", tooltiptext);
                    
                    //TODO: Status icons. The tab's icons are zero or more
                    //  URLs in the 'status', 'status2', 'action', 'readonly'
                    //  and 'image' attributes on the tab.
                    //  As a starter I tried to use just the 'status' icon,
                    //  but I cannot get the 'image' attribute to work as
                    //  follows:
                    //menuitem.setAttribute('type', 'menuitem-iconic');
                    //var image = tab.getAttribute("status");
                    //if (image) {
                    //    menuitem.setAttribute("image", image);
                    //}
                    
                    if (tab.selected) {
                        menuitem.setAttribute('class', 'selected');
                        menuitem.setAttribute('type', 'checkbox');
                        menuitem.setAttribute('checked', 'true');
                    } else {
                        menuitem.setAttribute('oncommand', 'this.tab.control.selectedItem = this.tab;');
                    }

                    menuitem.tab = tab;
                    return menuitem;
                } catch(ex) {
                    var _log = ko.logging.getLogger("scrolltabs");
                    _log.exception(ex, "error generating Window list "+
                                                "menuitem for '"+tab.label+"'");
                }
                return null;
                ]]>
                </body>
            </method>


            <method name="getTabList">
                <parameter name="dir"/>
                <body>
                <![CDATA[
                var popup = this.menuListPopup;
                while (popup.lastChild) {
                    popup.removeChild(popup.lastChild);
                }
        
                // get all the tab labels, and create the menu
                var child;
                for (var i = 0; i < this.childNodes.length; i++) {
                    child = this.childNodes[i];
                    if (child.localName == "tab" &&
                        (!child.hasAttribute("collapsed") || child.getAttribute("collapsed") == false) &&
                        (!child.hasAttribute("hidden") || child.getAttribute("hidden") == false)) {
                        popup.appendChild(this._createMenuItem(child));
                    }
                }
                ]]>
                </body>
            </method>

            <method name="advanceSelectedTab">
                <parameter name="aDir"/>
                <body>
                <![CDATA[
                // XXX copied from mozilla's tabbox.xml and modified to make
                // sure that non-tab children are not selected on ctrl-tab
                var startTab = this.selectedItem;
                var next = startTab[aDir == -1 ? "previousSibling" : "nextSibling"];

                while (next != startTab && (!next || (next.getAttribute("hidden") || next.localName != 'tab'))) {
                  if (next && (next.getAttribute("hidden") || next.localName != 'tab'))
                    next = next[aDir == -1 ? "previousSibling" : "nextSibling"];
                  if (!next)
                    next = aDir == 1 ? this.childNodes[0] : this.childNodes[this.childNodes.length - 1];
                }

                if (next && next != startTab) {
                  this.selectedItem = next;
                  if (this.getAttribute("setfocus") != "false") {
                    next.focus();
                    document.commandDispatcher.advanceFocusIntoSubtree(next);
                  }
                }
                ]]>
                </body>
            </method>

            <method name="scrollToTabIndex">
                <parameter name="index"/>
                <body>
                <![CDATA[
                    if (index >= 0 && index < this.childNodes.length) {
                        this.scrollBoxObject.ensureElementIsVisible(this.childNodes[index]);
                    }
                ]]>
                </body>
            </method>
        </implementation>
        <handlers>
            <handler event="underflow" phase="capturing">
            <![CDATA[
                this.removeAttribute("overflow");
                this.scrollBoxObject.scrollTo(0, 0)
            ]]>
            </handler>

            <handler event="overflow" phase="capturing">
            <![CDATA[
                this.setAttribute("overflow", "true");
                this.scrollBoxObject.ensureElementIsVisible(this.selectedItem);
            ]]>
            </handler>

            <handler event="select" phase="capturing">
            <![CDATA[
                this.scrollBoxObject.ensureElementIsVisible(this.selectedItem);
            ]]>
            </handler>
            <handler event="mousedown" phase="capturing">
            <![CDATA[
                // force a tab switch on mousedown so we always focus the
                // tabpanel, and cause a select event for the tab
                if (event.button != 1 && event.originalTarget.localName == 'tab') {
                    // set the selected item.  If the currently selected item
                    // is also the originalTarget, we'll 'selected' will be
                    // reset to true, and a select event will be issued.
                    this.selectedItem = event.originalTarget;
                }
            ]]>
            </handler>
        </handlers>
    </binding>

    <!-- Used clues from tabBindings.xul -->
    <binding id="tabbox-draggable" xbl:inherits="orient"
        extends="chrome://global/content/bindings/tabbox.xml#tabbox">
        <content>
            <xul:hbox class="tab-drop-indicator-bar" anonid="drop-indicator-bar" collapsed="true">
                <xul:hbox class="tab-drop-indicator" mousethrough="always"/>
            </xul:hbox>
            <children/>
        </content>

        <implementation>
            <field name="dropIndicatorBar">
              document.getAnonymousElementByAttribute(this, "anonid", "drop-indicator-bar");
            </field>

            <method name="getTabIndexById">
                <parameter name="id"/>
                <body>
                <![CDATA[
                    for(var i = 0; i < this._tabs.childNodes.length; i++) {
                        if(this._tabs.childNodes[i].getAttribute('id') == id) {
                            return i;
                        }
                    }
                    return -1;
                ]]>
                </body>
            </method>

            <method name="getTabById">
                <parameter name="id"/>
                <body>
                <![CDATA[
                    for (var i = 0; i < this._tabs.childNodes.length; i++) {
                        if (this._tabs.childNodes[i].getAttribute('id') == id)
                            return this._tabs.childNodes[i];
                    }
                    return null;
                ]]>
                </body>
            </method>

            <method name="getTabIdByIndex">
                <parameter name="index"/>
                <body>
                <![CDATA[
                    if(index >= 0 && index < this._tabs.childNodes.length) {
                        return this._tabs.childNodes[index].getAttribute('id');
                    }
                    return "";
                ]]>
                </body>
            </method>

            <method name="advanceSelectedTab">
                <parameter name="dir"/>
                <body>
                    <![CDATA[
                    this._tabs.advanceSelectedTab(dir, true);
                    ]]>
                </body>
            </method>
            
            <method name="getTabController">
                <parameter name="tab"/>
                <body>
                <![CDATA[
                    var parent = tab.parentNode;
                    while (parent) {
                      if (parent.localName == "tabbox")
                        return parent;
                      parent = parent.parentNode;
                    }
                    return null;
                ]]>
                </body>
            </method>

            <method name="getNewIndex">
              <parameter name="aEvent"/>
              <body>
                <![CDATA[
                  var i;
                  var tabs = this._tabs.childNodes;
                  if (window.getComputedStyle(this.parentNode, null).direction == "ltr") {
                    for (i = aEvent.target.localName == "tab" ? aEvent.target._tPos : 0; i < tabs.length; i++)
                      if (aEvent.screenX < tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2) 
                        return i;
                  } else {
                    for (i = aEvent.target.localName == "tab" ? aEvent.target._tPos : 0; i < tabs.length; i++)
                      if (aEvent.screenX > tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2)
                        return i;
                  }
                  return tabs.length;
                ]]>
              </body>
            </method>

            <method name="ensureTabPositionsAreSet">
              <body>
                <![CDATA[
                var tabs = this._tabs.childNodes;
                for (i = 0; i < tabs.length; i++) {
                    tabs[i]._tPos = i;
                }
                ]]>
              </body>
            </method>
        </implementation>

        <handlers>
            <handler event="dragstart">
            <![CDATA[
                //dump("scrolltabs:: dragstart\n");
                var tabsBoxObject = this._tabs.boxObject;
                if (event.screenX < tabsBoxObject.screenX ||
                    event.screenX > (tabsBoxObject.screenX + tabsBoxObject.width) ||
                    event.screenY < tabsBoxObject.screenY ||
                    event.screenY > (tabsBoxObject.screenY + tabsBoxObject.height)) {
                    // Not dragging in the tabs section, ignore the event.
                    //dump("scrolltabs:: dragstart:: not in tabs area\n");
                    return;
                }
                event.dataTransfer.mozSetDataAt("komodo/tab", event.target, 0);
                this.ensureTabPositionsAreSet();
            ]]>
            </handler>

            <handler event="dragenter">
            <![CDATA[
                //dump("scrolltabs:: dragenter\n");
                this.dropIndicatorBar.collapsed = false;
                this.ensureTabPositionsAreSet();
            ]]>
            </handler>

            <handler event="dragover">
            <![CDATA[
                //dump("scrolltabs:: dragover\n");
                var tabStrip = this._tabs.scrollbox;
                var ltr = (window.getComputedStyle(this.parentNode, null).direction
                           == "ltr");
    
                // autoscroll the tab strip if we drag over the scroll
                // buttons, even if we aren't dragging a tab, but then
                // return to avoid drawing the drop indicator
                var pixelsToScroll = 0;
                if (this._tabs.getAttribute("overflow") == "true") {
                  var targetAnonid = event.originalTarget.getAttribute("anonid");
                  switch (targetAnonid) {
                    case "scrollbutton-up":
                      pixelsToScroll = tabStrip.scrollIncrement * -1;
                      break;
                    case "scrollbutton-down":
                    case "tabs-list":
                      pixelsToScroll = tabStrip.scrollIncrement;
                      break;
                  }
                  if (pixelsToScroll)
                    tabStrip.scrollByPixels((ltr ? 1 : -1) * pixelsToScroll);
                }
    
                var newIndex = this.getNewIndex(event);
                var ib = this.dropIndicatorBar;
                var ind = ib.firstChild;
                var tabStripBoxObject = this._tabs.scrollBoxObject;
                var tabs = this._tabs.childNodes;
                var minMargin = tabStripBoxObject.x - this.boxObject.x;
                // make sure we don't place the tab drop indicator past the
                // edge, or the containing box will flex and stretch
                // the tab drop indicator bar, which will flex the url bar.  
                // XXX todo
                // just use first value if you can figure out how to get
                // the tab drop indicator to crop instead of flex and stretch
                // the tab drop indicator bar.
                var maxMargin = Math.min(minMargin + tabStripBoxObject.width, 
                                         ib.boxObject.x + ib.boxObject.width -
                                         ind.boxObject.width);
                if (!ltr)
                  [minMargin, maxMargin] = [this.boxObject.width - maxMargin,
                                            this.boxObject.width - minMargin];
                var newMargin, tabBoxObject;
                if (pixelsToScroll) {
                  // if we are scrolling, put the drop indicator at the edge
                  // so that it doesn't jump while scrolling
                  newMargin = (pixelsToScroll > 0) ? maxMargin : minMargin;
                }
                else {
                  if (newIndex == tabs.length) {
                    tabBoxObject =  tabs[newIndex-1].boxObject;
                    if (ltr)
                      newMargin = tabBoxObject.screenX - this.boxObject.screenX
                                  + tabBoxObject.width;
                    else
                      newMargin = this.boxObject.screenX - tabBoxObject.screenX
                                  + this.boxObject.width;
                  }
                  else {
                    tabBoxObject =  tabs[newIndex].boxObject;
                    if (ltr)
                      newMargin = tabBoxObject.screenX - this.boxObject.screenX;
                    else
                      newMargin = this.boxObject.screenX - tabBoxObject.screenX
                                  + this.boxObject.width - tabBoxObject.width;
                  }
                  // ensure we never place the drop indicator beyond our limits
                  if (newMargin < minMargin)
                    newMargin = minMargin;
                  else if (newMargin > maxMargin)
                    newMargin = maxMargin;
                }
    
                ind.style.MozMarginStart = newMargin + 'px';
    
                ib.collapsed = false;
                return true;
            ]]>
            </handler>

            <handler event="dragleave">
            <![CDATA[
                //dump("scrolltabs:: dragleave\n");
                this.dropIndicatorBar.collapsed = true;
            ]]>
            </handler>

            <handler event="drop">
            <![CDATA[
                //dump("scrolltabs:: drop\n");

                // Are they dragging a Komodo tab - as we don't accept any other
                // drop data.
                var dataTransfer = event.dataTransfer;
                if (!dataTransfer || dataTransfer.mozItemCount != 1) {
                    return false;
                }
                var mozTypes = dataTransfer.mozTypesAt(0);
                if (mozTypes.length != "1" || mozTypes[0] != "komodo/tab") {
                    return false;
                }
                var sourceTab = dataTransfer.mozGetDataAt("komodo/tab", 0);
                if (!sourceTab) {
                    return false;
                }
                var sourceTabbox = this.getTabController(sourceTab);
                var targetTabbox = this;

                var sourceIndex = sourceTabbox.getTabIndexById(sourceTab.id);
                var targetIndex = targetTabbox.getNewIndex(event);
                var tabs = targetTabbox._tabs.childNodes;
                var targetTab = tabs[targetIndex];

                //dump("move tab at sourceIndex="+sourceIndex
                //     +" (sourceTabbox "+sourceTabbox.parentNode.getAttribute("id")
                //     +") to targetIndex="+targetIndex
                //     +" (targetTabbox "+targetTabbox.parentNode.getAttribute("id")
                //     +")\n");

                targetTabbox.dropIndicatorBar.collapsed = true;
                sourceTabbox.dropIndicatorBar.collapsed = true;

                if (sourceTab.ownerDocument != document) {
                    // 1. Moving a tab from one Komodo window to another.
                    var sourceView = sourceTabbox.parentNode.currentView;
                    
                    // Gather the data we need to open the view in the
                    // target window.
                    var uri = sourceView.document.file.URI;
                    var viewType = sourceView.getAttribute("type");
                    var line = (viewType == "editor" ? sourceView.currentLine : null);
                    var viewList = targetTabbox.parentNode;
                    
                    // Close the source view first to ensure unsaved
                    // changes, etc. get handled first.
                    if (!sourceView.close()) {
                        return true;
                    }
                    
                    // Open the new view.
                    if (line != null) {
                        ko.views.manager.doFileOpenAtLineAsync(
                            uri, line, viewType, viewList, targetIndex);
                    } else {
                        ko.views.manager.doFileOpenAsync(
                            uri, viewType, viewList, targetIndex);
                    }
                    window.focus();
                } else if (sourceTabbox != targetTabbox) {
                    // 2. Moving to the other view-tabbed tab box in the
                    //    same Komodo window.
                    var sourceView = sourceTabbox.parentNode.currentView;
                    ko.views.manager.topView.moveView(sourceView, targetIndex);
                } else {
                    // 3. Moving within the same view-tabbed tab box.
                    // Don't do anything if just dragging to the same spot.
                    if ((sourceIndex != targetIndex) &&
                        !(targetIndex == (sourceIndex+1) && targetIndex == tabs.length)) {
                        if (typeof(targetTab) == 'undefined') {
                            targetTabbox._tabs.appendChild(sourceTab);
                        } else {
                            targetTabbox._tabs.insertBefore(sourceTab, targetTab);
                        }
                    }
                    // Ensure to focus back on the editor now.
                    var view = ko.views.manager.currentView;
                    if (view) {
                        view.setFocus();
                    }
                }

                event.cancelBubble = true;
                return true;
            ]]>
            </handler>

            <handler event="dragend">
            <![CDATA[
                //dump("scrolltabs:: dragend\n");
                this.dropIndicatorBar.collapsed = true;
                // Drag is over, re-focus on the current view - bug 84215.
                // Though if it's to another window - all bets are off.
                if (event.originalTarget.ownerDocument == document) {
                    var view = ko.views.manager.currentView;
                    if (view) {
                        view.setFocus();
                    }
                }
                return true;
            ]]>
            </handler>
        </handlers>
    </binding>

</bindings>
