<?xml version="1.0"?>
<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is Komodo.
   -
   - The Initial Developer of the Original Code is
   - ActiveState Software Inc.
   - Portions created by the Initial Developer are Copyright (C) 2011
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->
<!DOCTYPE bindings PUBLIC "-//MOZILLA//DTD XBL V1.0//EN" "http://www.mozilla.org/xbl">

<bindings
    xmlns="http://www.mozilla.org/xbl"
    xmlns:xbl="http://www.mozilla.org/xbl"
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

<!--
  - Panes for sidebars and the like
  - See kd 0272 for specifications
  -->

  <binding id="pane" extends="chrome://global/content/bindings/tabbox.xml#tabbox">
    <content>
      <xul:hbox class="pane-tabs-container">
        <!-- this is for the "sidebar" and "horzontal" modes -->
        <xul:tabs anonid="tabs"
                  closecollapsed="false"
                  orient="this is here to prevent the tabs binding setting it to horizontal"
                  xbl:inherits="rotation,label"
                  onclose="var elem = this;
                           while (!/pane/.test(elem.localName))
                             elem = document.getBindingParent(elem);
                           elem.collapsed = true;"/>
      </xul:hbox>
      <xul:vbox flex="1">
        <!-- this is here for the "vertical" case -->
        <xul:hbox class="tabs-vertical-label">
          <xul:label xbl:inherits="value=label"/>
          <xul:spacer/>
          <xul:toolbarbutton anonid="panel-close-button"
                  class="tabs-closebutton"
                  buttonstyle="pictures"
                  oncommand="document.getBindingParent(this).collapsed = true;"/>
        </xul:hbox>
        <xul:tabpanels anonid="tabpanels" flex="1">
          <children/>
        </xul:tabpanels>
      </xul:vbox>
    </content>
    <implementation>
      <method name="addWidget">
        <!--
          - Add the given widget to the pane
          -->
        <parameter name="widget"/>
        <body>
        <![CDATA[
          if (!widget.tab) {
            var tab = this.ownerDocument.createElementNS(this.namespaceURI, "tab");
            tab.setAttribute("observes", widget.id);
            tab.setAttribute("linkedpanel", widget.id);
            widget.tab = tab;
          }
          this.tabs.appendChild(widget.tab);
          // we never want to have flex by the attr; remove the flex generated
          // by the tab binding. (we can do it from css if we really want to.)
          widget.tab.removeAttribute("flex");
          this.tabpanels.appendChild(widget);

          // update the menu listing the widgets to show
          var refElem = document.getElementById("menu_view_tabs_stub_" + this.id);
          if (refElem) {
            var menuitem = document.createElement("menuitem");
            menuitem.setAttribute("label", widget.getAttribute("label"));
            menuitem.setAttribute("type", "checkbox");
            menuitem.setAttribute("widget", widget.id);
            refElem.parentNode.insertBefore(menuitem, refElem);
            menuitem.addEventListener("command",
                                      ko.uilayout.ensureTabShown.bind(ko.uilayout, widget, true),
                                      false);
          }
        ]]>
        </body>
      </method>

      <method name="removeWidget">
        <!--
          - Remove a given widget.
          - This should not be used if you just want to hide the widget
          - temporarily.
          -->
        <parameter name="widget"/>
        <body>
        <![CDATA[
          if (widget.parentNode) {
            widget.parentNode.removeChild(widget);
          }
          if (widget.tab) {
            if (widget.tab.parentNode) {
              // find another tab to select
              var tab = widget.tab.nextElementSibling;
              for (; tab; tab = tab.nextElementSibling) {
                if (!tab.hasAttribute("collapsed")) {
                  break;
                }
              }
              if (!tab) {
                tab = widget.tab.previousElementSibling;
                for (; tab; tab = tab.previousElementSibling) {
                  if (!tab.hasAttribute("collapsed")) {
                    break;
                  }
                }
              }
              if (tab) {
                this.selectedTab = tab;
              } else {
                // we're removing the only visible widget. Hide.
                this.collapsed = true;
              }
              widget.tab.parentNode.removeChild(widget.tab);
            }
            widget.tab = null;
          }
          // update the menu listing the widgets
          var refElem = document.getElementById("menu_view_tabs_stub_" + this.id);
          var menu = refElem.parentNode;
          var menuitem = menu.querySelector("menuitem[widget='" + widget.id + "']");
          if (menuitem) {
            menuitem.parentNode.removeChild(menuitem);
          }
        ]]>
        </body>
      </method>

      <property name="splitter">
        <getter>
        <![CDATA[
          for each (var elem in [this.previousElementSibling, this.nextElementSibling]) {
            if (elem && elem.namespaceURI == this.namespaceURI && elem.localName == "splitter") {
              return elem;
            }
          }
          return null;
        ]]>
        </getter>
      </property>
      <property name="tabs">
        <getter>
          return this.ownerDocument.getAnonymousElementByAttribute(this, "anonid", "tabs");
        </getter>
      </property>
      <property name="tabpanels">
        <getter>
          return this.ownerDocument.getAnonymousElementByAttribute(this, "anonid", "tabpanels");
        </getter>
      </property>
      <property name="collapsed">
        <getter>
        <![CDATA[
          return this.hasAttribute("collapsed");
        ]]>
        </getter>
        <setter>
        <![CDATA[
          /* note that the splitter is expected to observe the collapsed attr
           * on this element, and the toolbar button is expected to observe the
           * checked attr
           */
          if (val) {
            this.setAttribute("collapsed", true);
            this.removeAttribute("checked"); // for reflecting to toolbarbutton
          } else {
            this.removeAttribute("collapsed");
            this.setAttribute("checked", true);
          }
        ]]>
        </setter>
      </property>

      <constructor>
      <![CDATA[
      try{
        if (!this.hasAttribute("type")) {
          // no type; this leads to broken UI, so default to something
          this.setAttribute("type", "sidebar");
        }
        if (this.hasAttribute("pref")) {
          // the type of this pane is persisted in prefs
          var prefs = Components.classes["@activestate.com/koPrefService;1"]
                                .getService(Components.interfaces.koIPrefService)
                                .effectivePrefs;
          var prefid = this.getAttribute("pref");
          if (prefs.hasStringPref(prefid)) {
            this.setAttribute("type", prefs.getStringPref(prefid));
          }
        }
        // re-inserting the tabpanel in the same place causes it to show up
        // in DOM inspector's tree (still as a anonymous node)...
        // (this is not strictly necessary, since things still work without it)
        this.tabpanels.parentNode.insertBefore(this.tabpanels, this.tabpanels.nextSibling);
        // re-insert the widgets so we can properly construct tabs for them
        var widgets = Array.slice(this.childNodes);
        for each (var widget in widgets) {
          this.addWidget(widget);
        }
      } catch (e) { Components.utils.reportError(e); }
      ]]>
      </constructor>
    </implementation>
    <handlers>
      <handler event="select" phase="bubbling">
      <![CDATA[
        if (event.originalTarget == this.tabs) {
          var tab = this.tabs.selectedItem;
          this.setAttribute("label", tab.label);
          var panel = this.ownerDocument.getElementById(tab.linkedPanel);
          this.tabpanels.selectedPanel = panel;
        }
      ]]>
      </handler>
    </handlers>
  </binding>

  <binding id="pane-browser" extends="chrome://global/content/bindings/browser.xml#browser">
    <content disablehistory="true">
      <broadcasterset anonid="pane_broadcasterset"/>
      <children/>
    </content>

    <implementation>
      <method name="hookupObservers">
        <!--
          - hook up the observes= elements in the child document so they work
          - @param containerElement An element in the child document that can be
          -         used to hold generated elements
          - @param parentNode [optional] the node from which to look for observes=
          -         attributes; defaults to the content document
          -->
        <parameter name="containerElement"/>
        <parameter name="parentNode"/>
        <body>
        <![CDATA[
          if (typeof(containerElement) == "string") {
            containerElement = this.contentDocument.getElementById(containerElement);
          } else if (!containerElement) {
            containerElement = this.contentDocument.documentElement;
          }
          var parentSet = this.ownerDocument.getAnonymousElementByAttribute(this, "anonid", "pane_broadcasterset");

          var onBroadcast = (function onBroadcast(aCmdId) {
            if (typeof(aCmdId) != "string") {
              // This is not a string; therefore, it's an onbroadcast event.
              // Figure out the target element and read the id off that.
              aCmdId = aCmdId.target.getAttribute("element");
            }
            var srcCmd = this.ownerDocument.getElementById(aCmdId);
            var destCmd = this.contentDocument.getElementById(aCmdId);
            for each (let attr in Array.slice(destCmd.attributes)) {
                if (!srcCmd.hasAttribute(attr.name))
                    destCmd.removeAttribute(attr.name);
            }
            for each (let attr in Array.slice(srcCmd.attributes)) {
                destCmd.setAttributeNS(attr.namespaceURI, attr.name, attr.value);
            }
          }).bind(this);

          // Find all elements with observes= attributes and create proxying
          // <observes> elements in the parent document, and <command> elements
          // in the child document.
          if (!parentNode) parentNode = this.contentDocument;
          var elems = Array.slice(parentNode.querySelectorAll("[observes]"));
          for each (let elem in elems) {
            let cmdId = elem.getAttribute("observes");
            let srcCmd = this.ownerDocument.getElementById(cmdId);
            if (!srcCmd) continue; // not observing into the parent
            let destCmd = this.contentDocument.getElementById(cmdId);
            if (!destCmd) {
              // create a <command> in the child document and force refresh
              destCmd = this.contentDocument.createElement("command");
              destCmd.setAttribute("id", cmdId);
              containerElement.appendChild(destCmd);
              onBroadcast(cmdId);

              // create a <observes> in the parent and listen for changes
              let observer = this.ownerDocument.createElement("observes");
              observer.setAttribute("element", cmdId);
              observer.setAttribute("attribute", "*");
              parentSet.appendChild(observer);
              observer.addEventListener("broadcast", onBroadcast, false);
            }
            // re-insert the element to make sure observes= gets hooked up :(
            elem.parentNode.insertBefore(elem, elem.nextSibling);
          }
        ]]>
        </body>
      </method>
    </implementation>
    
    <handlers>
      <handler event="DOMWindowCreated" phase="target"><![CDATA[
        // inject the bits the content window will need; this is the exposed API.
        this.contentWindow.parent = window;
        ["ko", "xtk", "gEditorTooltipHandler"].forEach(function(prop) {
          this.contentWindow.__defineGetter__(prop, function()window[prop]);
        }, this);
      ]]></handler>
    </handlers>
  </binding>

  <binding id="widget" extends="#pane-browser">
    <!--
      - A widget to be displayed in a <ko-pane>.
      - It's a cross between a <tabpanel> and a <browser>.
      - Instantiate as <browser type="ko-widget">
      -->
    <implementation>
      <property name="tabbox">
        <getter>
        <![CDATA[
          /**
           * This is more complicated than normal because we want to look for
           * any element that uses the tabbox binding, instead of matching on
           * the tag name.
           */
          var utils = Components.classes["@mozilla.org/inspector/dom-utils;1"]
                                .getService(Components.interfaces.inIDOMUtils);
          const TABBOX_URL = "chrome://global/content/bindings/tabbox.xml#tabbox";
          var result = null;
          for (var parent = this.parentNode; !result && parent; parent = parent.parentNode) {
              if (!(parent instanceof Element)) continue;
              var urls = utils.getBindingURLs(parent).enumerate();
              while (urls.hasMoreElements()) {
                  var uri = urls.getNext().QueryInterface(Components.interfaces.nsIURI);
                  if (uri.spec == TABBOX_URL) {
                      result = parent;
                      break;
                  }
              }
          }
          return result;
        ]]>
        </getter>
      </property>
      <constructor>
      <![CDATA[
        if (!this.hasAttribute("disablehistory")) {
          this.setAttribute("disablehistory", true);
        }
      ]]>
      </constructor>
    </implementation>
  </binding>

</bindings>
